<html>
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css"
	integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous">
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"
	integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj"
	crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"
	integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo"
	crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js"
	integrity="sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI"
	crossorigin="anonymous"></script>

<head>
	<title>WebGL Minecraft</title>
	<link rel="shortcut icon" href="textures/icon.png">
	<style>
		body {
			margin: 0;
		}

		canvas {
			display: block;
		}
	</style>
</head>

<button id="button1" style="position: absolute; left: 50%; transform: translate(-50%, 0);">Press to Lock Cursor</button>
<img src="textures/dot.png" style="position: absolute; width: 10px; left: 50%; top: 50%; transform: translate(-50%, -50%);">

<body id="hide_id" style="background-color: black;">

	<script src="perlin.js"></script>
	<script src="three.js-master/build/three.js"></script>
	<script src="three.js-master/examples/js/controls/PointerLockControls.js"></script>
	<script src="three.js-master/examples/js/libs/stats.min.js"></script>
	<script src = "gpu.js-develop/dist/gpu-browser.js"></script>
	<script>
		javascript:(function(){var script=document.createElement('script');script.onload=function(){var stats=new Stats();document.body.appendChild(stats.dom);requestAnimationFrame(function loop(){stats.update();requestAnimationFrame(loop)});};script.src='https://github.com/mrdoob/stats.js/blob/master/build/stats.min.js';document.head.appendChild(script);})()		
		var renderer = new THREE.WebGLRenderer();
		renderer.setSize(window.innerWidth, window.innerHeight);
		document.body.appendChild(renderer.domElement);
		var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 100);
		camera.position.y = 10;
		var scene = new THREE.Scene();
		addLighting();

		function addLighting()
		{
			const skyColor = 0xB1E1FF;  // light blue
			const groundColor = 0xB97A20;  // brownish orange
			const intensity = 1;
			const light = new THREE.HemisphereLight(skyColor, groundColor, intensity);
			scene.background = new THREE.Color(skyColor);
			const near = 79;
			const far = 80;
			scene.fog = new THREE.Fog(skyColor, near, far);
			scene.add(light)
		}

		// Inputs //
		let controls = new THREE.PointerLockControls(camera, renderer.domElement);
		let clock = new THREE.Clock();

		let btn = document.querySelector("#button1");
		btn.addEventListener('click', ()=>{
			controls.lock();
		})
		controls.addEventListener('lock', ()=> {
			btn.innerHTML = "Press ESC to Unlock Cursor"
		})
		controls.addEventListener('unlock', ()=> {
			btn.innerHTML = "Press to Lock Cursor"
		})

		let keyboard = [];
		addEventListener("keydown", (e) => {
			keyboard[e.key] = true;
		});
		addEventListener("keyup", (e) => {
			keyboard[e.key] = false;
		});

		function processKeyboard(delta) {
			let speed = 5;
			let actualSpeed = speed * delta;
			if (keyboard["w"]) {
				controls.moveForward(actualSpeed);
			}
			if (keyboard["s"]) {
				controls.moveForward(-actualSpeed);
			}
			if (keyboard["a"]) {
				controls.moveRight(-actualSpeed);
			}
			if (keyboard["d"]) {
				controls.moveRight(actualSpeed);
			}
			if (keyboard[" "]) {
				camera.position.y += actualSpeed;
			}
			if (keyboard["q"]) {
				camera.position.y -= actualSpeed;
			}
		}

		function distanceBetween(x1, z1, x2, z2) {
			return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(z1 - z2, 2));
		}

		let emptyMaterial = new THREE.MeshLambertMaterial({color:0x645910});

		let data = new Map();

		window.onmousedown = function() {
			if (INTERSECTED && INTERSECTED.name != "bottom") {
				INTERSECTED.material = emptyMaterial;
				scene.remove(INTERSECTED);
				let x = INTERSECTED.position.x;
				let y = INTERSECTED.position.y;
				let z = INTERSECTED.position.z;
				data[x+","+z][y] = null;
				if (data[x+","+z][y-1]) {
						scene.add(data[x+","+z][y-1]);
				}
				if (data[(x+1)+","+z][y]) {
						scene.add(data[(x+1)+","+z][y]);
				}
				if (data[(x-1)+","+z][y]) {
						scene.add(data[(x-1)+","+z][y]);
				}
				if (data[x+","+(z+1)][y]) {
						scene.add(data[x+","+(z+1)][y]);
				}
				if (data[x+","+(z-1)][y]) {
						scene.add(data[x+","+(z-1)][y]);
				}
			}
		}

		function generateBlock(x, z) {
			var height = Math.floor(30 * noise.perlin2(x/75, z/75));
			if (data[x+","+z] == null) {
				data[x+","+z] = new Map();
			}
			let block = drawBlock(x, z, height);
			block.name = "block";
			data[x+","+z][height] = block;
			for (let i = height-1; i >= height-4; i--) {
				block = drawBlock(x, z, i);
				scene.remove(block);
				block.name = "block";
				if (i == height-4) {
					block.material = new THREE.MeshLambertMaterial({color: 0x000000});
					block.name = "bottom";
					scene.remove(block);
				}
				data[x+","+z][i] = block;
			}
		}

		let geometry = new THREE.BoxBufferGeometry();
		function drawBlock(x, z, y) {
			const grassMaterial = new THREE.MeshLambertMaterial({color: 0x02cf08});
			mesh = new THREE.Mesh(geometry, grassMaterial);
			mesh.position.x = x;
			mesh.position.y = y;
			mesh.position.z = z;
			mesh.rotation.x = -Math.PI/2;
			scene.add(mesh);
			return mesh;
		}

		let prevX = 1;
		let prevZ = 1;
		function processLand() {
			let x = Math.floor(camera.position.x + 0.5);
			let z = Math.floor(camera.position.z + 0.5);
			if ((x != prevX || z != prevZ) && (camera.position.x % 1 <= 0.1 || camera.position.z % 1 <= 0.1)) {
				drawBlocks(x, z);
				removeBlocks(x, z);
				prevX = x;
				prevZ = z;
			}
		}

		let blockRenderDist = 40;
		drawStart();
		function drawStart() {
			for (let r = -blockRenderDist - 10; r < blockRenderDist+11; r++) {
				for (let c = -blockRenderDist - 10; c < blockRenderDist+11; c++) {
					generateBlock(r, c);
				}
			}
		}

		function drawBlocks(playerX, playerZ) {
			for (let c = playerZ + blockRenderDist - 2; c <= playerZ + blockRenderDist; c++) {
				for (let r = playerX - blockRenderDist; r <= playerX + blockRenderDist; r++) {
					let blocks = data[r+","+c];
					if (blocks != null ) {
						for (var i in blocks) {
							let block = blocks[i];
							if (block != null) {
								if (block.material != emptyMaterial && !scene.children.includes(block) && block.name == "block") {
									scene.add(block);
								}
							}
						}
					} else {
						generateBlock(r, c);
					}
				}
			}
			for (let c = playerZ - blockRenderDist + 2; c >= playerZ - blockRenderDist; c--) {
				for (let r = playerX - blockRenderDist; r <= playerX + blockRenderDist; r++) {
					let blocks = data[r+","+c];
					if (blocks != null ) {
						for (var i in blocks) {
							let block = blocks[i];
							if (block != null) {
								if (block.material != emptyMaterial && !scene.children.includes(block)) {
									scene.add(block);
								}
							}
						}
					} else {
						generateBlock(r, c);
					}
				}
			}
			for (let r = playerX + blockRenderDist -2; r <= playerX + blockRenderDist; r++) {
				for (let c = playerZ - blockRenderDist; c <= playerZ + blockRenderDist; c++) {
					let blocks = data[r+","+c];
					if (blocks != null ) {
						for (var i in blocks) {
							let block = blocks[i];
							if (block != null) {
								if (block.material != emptyMaterial && !scene.children.includes(block)) {
									scene.add(block);
								}
							}
						}
					} else {
						generateBlock(r, c);
					}
				}
			}
			for (let r = playerX - blockRenderDist +2; r >= playerX - blockRenderDist; r--) {
				for (let c = playerZ - blockRenderDist; c <= playerZ + blockRenderDist; c++) {
					let blocks = data[r+","+c];
					if (blocks != null ) {
						for (var i in blocks) {
							let block = blocks[i];
							if (block != null) {
								if (block.material != emptyMaterial && !scene.children.includes(block)) {
									scene.add(block);
								}
							}
						}
					} else {
						generateBlock(r, c);
					}
				}
			}
		}

		function removeBlocks(playerX, playerZ) {
			for (var i in scene.children) {
				let block = scene.children[i];
				if (block.name == "block" || block.name == "bottom") {
					if (block.material == emptyMaterial || (Math.abs(playerZ - block.position.z) > blockRenderDist-0.9 || Math.abs(playerX - block.position.x) > blockRenderDist-0.9)) {
						scene.remove(block);
					}
				}
			}
		}

		let INTERSECTED;
		function checkMouse() {
			let raycaster = new THREE.Raycaster();
			const center = new THREE.Vector2(0, 0);
			raycaster.setFromCamera( center, camera );
			const intersects = raycaster.intersectObjects( scene.children );
			if (intersects.length > 0) {
				if (INTERSECTED != intersects[0].object) {
					if (INTERSECTED) {
						INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
					}
					INTERSECTED = intersects[0].object;
					INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
					INTERSECTED.material.emissive.setHex( 0xf0260f );
				}
			} else {
				if (INTERSECTED) {
					INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
				}
				INTERSECTED = null;
			}
		}

		function drawScene() {
			renderer.render(scene, camera);
			let delta = clock.getDelta();
			processKeyboard(delta);
			processLand();
			checkMouse();
			requestAnimationFrame(drawScene);
		}

		drawScene();

	</script>
</body>

</html>
