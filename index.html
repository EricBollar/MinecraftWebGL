<html>
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css"
	integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous">
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"
	integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj"
	crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"
	integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo"
	crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js"
	integrity="sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI"
	crossorigin="anonymous"></script>

<head>
	<title>WebGL Minecraft</title>
	<link rel="shortcut icon" href="textures/icon.png">
	<style>
		body {
			margin: 0;
		}

		canvas {
			display: block;
		}
	</style>
</head>

<button id="button1" style="position: absolute; left: 50%; transform: translate(-50%, 0);">Press to Lock Cursor</button>
<img src="textures/dot.png" style="position: absolute; width: 10px; left: 50%; top: 50%; transform: translate(-50%, -50%);">
<h2 style="position: absolute; bottom: 0%; left: 10px;"><span class="badge badge-secondary" id="playerCoords">(0, 0)</span></h2>

<body id="hide_id" style="background-color: black;">

	<script src="perlin.js"></script>
	<script src="three.js-master/build/three.js"></script>
	<script src="three.js-master/examples/js/controls/PointerLockControls.js"></script>
	<script src="three.js-master/examples/js/libs/stats.min.js"></script>
	<script>
		javascript:(function(){var script=document.createElement('script');script.onload=function(){var stats=new Stats();document.body.appendChild(stats.dom);requestAnimationFrame(function loop(){stats.update();requestAnimationFrame(loop)});};script.src='https://github.com/mrdoob/stats.js/blob/master/build/stats.min.js';document.head.appendChild(script);})()		
		let renderer = new THREE.WebGLRenderer();
		renderer.setSize(window.innerWidth, window.innerHeight);
		document.body.appendChild(renderer.domElement);
		let camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.001, 50);
		camera.position.y = 5;
		let scene = new THREE.Scene();
		addLighting();
		
		let pause = false;

		function addLighting()
		{
			let sky = 0xffffff;
			const light = new THREE.HemisphereLight(sky, 0x50544f, 1);
			scene.background = new THREE.Color(sky);
			const near = 10;
			const far = 16;
			scene.fog = new THREE.Fog(sky, near, far);
			scene.add(light)
		}

		// Inputs //
		let controls = new THREE.PointerLockControls(camera, renderer.domElement);
		let clock = new THREE.Clock();

		let btn = document.querySelector("#button1");
		btn.addEventListener('click', ()=>{
			controls.lock();
		})
		controls.addEventListener('lock', ()=> {
			btn.innerHTML = "Press ESC to Unlock Cursor"
			pause = true;
		})
		controls.addEventListener('unlock', ()=> {
			btn.innerHTML = "Press to Lock Cursor"
			pause = false;
		})

		let keyboard = [];
		addEventListener("keydown", (e) => {
			keyboard[e.key] = true;
		});
		addEventListener("keyup", (e) => {
			keyboard[e.key] = false;
		});

		let mode = 1;
		let prev = new THREE.Vector3(0, 0, 0);
		function processKeyboard(delta) {
			let speed = 3;
			let actualSpeed = speed * delta; 
			if (keyboard["w"]) {
				controls.moveForward(actualSpeed);
				checkWalls();
			}
			if (keyboard["s"]) {
				controls.moveForward(-actualSpeed);
				checkWalls();
			}
			if (keyboard["a"]) {
				controls.moveRight(-actualSpeed);
				checkWalls();
			}
			if (keyboard["d"]) {
				controls.moveRight(actualSpeed);
				checkWalls();
			}
			if (keyboard[" "]) {
				if (mode == 0) {
					if (canJump) {
						velocity.y = 2;
						canJump = false;
					}
				} else {
					camera.position.y += actualSpeed;
				}
			}
			if (keyboard["q"]) {
				camera.position.y -= actualSpeed;
				//checkWalls();
			}
			if (keyboard["m"]) {
				
			}
			if (mode == 0) {
				playerPhysics(speed, delta);
				checkWalls();
			}
		}

		function checkWalls() {
			let x = Math.floor(camera.position.x+0.5);
			let y = Math.floor(camera.position.y+0.5);
			let z = Math.floor(camera.position.z+0.5);
			let key = getKey(x, z);
			let key2 = getKey(Math.floor(prev.x, prev.z));
			if (data[key][y-2] != null) {
				canJump = true;
			}
			if (data[key][y-2] != null || data[key][y]) {
				camera.position.x = prev.x;
				camera.position.y = prev.y;
				camera.position.z = prev.z;
			} else {
				prev = new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z);
			}
		}

		let data = new Map();

		window.onmousedown = function(e) {
			e = e || window.event;
			if (e.keyCode || e.which == 1) { // left click
				if (INTERSECTED && INTERSECTED.name != "bottom" && pause) {
					destroyBlock(INTERSECTED.position.x, INTERSECTED.position.y, INTERSECTED.position.z);
				}
			} else if (e.keyCode || e.which == 3) { // right click
				let posX = INTERSECTED.position.x + face.normal.x;
				let posY = INTERSECTED.position.y + face.normal.y;
				let posZ = INTERSECTED.position.z + face.normal.z;
				let key = getKey(posX, posZ);
				if (data[key][posY] == null) {
					data[key][posY] = drawBlock(posX, posZ, posY, 5);
				}
			}
		}

		function destroyBlock(x, y, z) {
			let key = getKey(x, z);
			scene.remove(data[key][y]);
			data[key][y] = null;

			// update blocks surrounding
			if (data[key][y-1]) {
				data[key][y-1].visible = true;
			}
			if (data[key][y+1]) {
				data[key][y+1].visible = true;
			}
			key = getKey(x+1, z);
			if (data[key][y]) {
				data[key][y].visible = true;
			}
			key = getKey(x-1, z);
			if (data[key][y]) {
				data[key][y].visible = true;
			}
			key = getKey(x, z+1);
			if (data[key][y]) {
				data[key][y].visible = true;
			}
			key = getKey(x, z-1);
			if (data[key][y]) {
				data[key][y].visible = true;
			}
		}

		let toAdd = [];
		noise.seed(Math.random());

		function getHeightValue(x, z) {
			return 2+Math.floor(10 * Math.abs(noise.perlin2(x/50, z/50)));
		}

		function getBlock(x, y, z) {
			return data[getKey(x, z)][y];
		}

		function getKey(x, z) {
			return x+","+z;
		}

		function generateCoordinate(x, z) {
			var height = getHeightValue(x, z);

			let key = getKey(x, z); // grass
			if (!data[key]) {
				data[key] = new Map();
			}
			let block = drawBlock(x, z, height, 1);
			data[key][height] = block;

			for (let i = height-1; i >= 0; i--) {
				let block;
				if (i == 0) {
					block = drawBlock(x, z, i, 0); // bedrock
					block.name = "bottom";
				} else if (i == height-1 || i == height - 2) {
					block = drawBlock(x, z, i, 6); // dirt
				} else if (Math.floor(Math.random() * 200) + 1 == 5) { 
					block = drawBlock(x, z, i, 5); // diamond ?
				} else {
					block = drawBlock(x, z, i, 2); // stone
				}
				block.visible = false;
				data[key][i] = block;
			}

			if (Math.floor(Math.random() * 150) + 1 == 5) { // tree ?
				let h = Math.floor(Math.random() * 3 + 4.5);
				for (let i = 1; i < h; i++) {
					let block = drawBlock(x, z, height+i, 3);
					data[key][height+i] = block;
					if (i >= 3) {
						block = drawBlock(x+1, z, height+i, 4);
						toAdd.push(block);
						block = drawBlock(x-1, z, height+i, 4);
						toAdd.push(block);
						block = drawBlock(x, z+1, height+i, 4);
						toAdd.push(block);
						block = drawBlock(x, z-1, height+i, 4);
						toAdd.push(block);
					}
				}
				let block = drawBlock(x, z, height+h, 4);
				data[key][height+h] = block;
			}
		}

		// let grassColor = 0x038927;
		// let stoneColor = 0x747f7c;
		// let bottomColor = 0x351800;
		// let treeColor = 0xb37d0c;
		// let leafColor = 0x6fde62;
		// let diamondColor = 0x0a9ff5;
		let base = new THREE.BoxGeometry(1, 1, 1);
		let loader = new THREE.TextureLoader();
		let grassMap = loader.load("textures/grassTop.jpeg");
		let dirtMap = new THREE.TextureLoader().load("textures/dirt.jpeg");
		let stoneMap = loader.load("textures/stone.jpeg");
		let treeMap = loader.load("textures/tree.jpeg");
		let leafMap = loader.load("textures/leaf.png");
		let diamondMap = loader.load("textures/diamond.jpeg");
		let bottomMap = loader.load("textures/bedrock.png");
		let clientSideTestMap = loader.load("https://threejsfundamentals.org/threejs/resources/images/wall.jpg");
		
		function drawBlock(x, z, y, value) {
			switch (value) {
				case 0: m = bottomMap; break;
				case 1: m = grassMap; break;
				case 2: m = stoneMap; break;
				case 3: m = treeMap; break;
				case 4: m = leafMap; break;
				case 5: m = diamondMap; break;
				case 6: m = dirtMap; break;
			}
			let geometry = base.clone();
			var material = new THREE.MeshPhongMaterial({map: m, vertexColors: THREE.FaceColors});
			var mesh = new THREE.Mesh( geometry, material);
			mesh.position.x = x;
			mesh.position.y = y;
			mesh.position.z = z;
			mesh.name = "block";
			scene.add(mesh);
			mesh.castShadow = true;
			mesh.receiveShadow = true;
			return mesh;
		}

		let prevX = 1;
		let prevZ = 1;
		let playerCoordsUI = document.getElementById("playerCoords");
		function processLand() {
			let x = Math.floor(camera.position.x + 0.5);
			let z = Math.floor(camera.position.z + 0.5);
			if ((x != prevX || z != prevZ) && (camera.position.x % 1 <= 0.1 || camera.position.z % 1 <= 0.1)) {
				drawBlocks(x, z);
				removeBlocks(x, z);
				prevX = x;
				prevZ = z;
			}
			let y = Math.floor(camera.position.y + 0.5);
			playerCoordsUI.innerHTML = "(x:" + x + ", y:" + y + ", z:" + z + ")";
		}

		let blockRenderDist = 20;
		generateStart();
		function generateStart() {
			drawStart();
			let tall = 0;
			let key = getKey(0, 0);
			for (var i in data[key]) {
				if (data[key][i].position.y > tall) {
					tall = data[key][i].position.y;
				}
			}
			camera.position.y = tall + 3;
		}

		function drawStart() {
			for (let r = -blockRenderDist; r < blockRenderDist; r++) {
				for (let c = -blockRenderDist; c < blockRenderDist; c++) {
					generateCoordinate(r, c);
				}
			}
		}

		function updateCrossovers() { // e.g. leaves
			for (var i in toAdd) {
				let block = toAdd[i];
				let x = block.position.x;
				let y = block.position.y;
				let z = block.position.z;
				let key = getKey(x, z);
				if (!data[key]) {
					generateCoordinate(x, z);
				}
				data[key][y] = block;
			}
			for (let i = 0; i < toAdd.length; i++) {
				toAdd.pop();
			}
		}

		function drawCoord(x, z) {
			let key = getKey(x, z);
			let blocks = data[key];
			if (blocks != null ) {
				for (var i in blocks) {
					let block = blocks[i];
					if (block != null) {
						if (!scene.children.includes(block)) {
							scene.add(block);
						}
					}
				}
			} else {
				generateCoordinate(x, z);
			}
		}

		function drawBlocks(playerX, playerZ) {
			updateCrossovers();
			for (let c = playerZ + blockRenderDist - 1; c <= playerZ + blockRenderDist; c++) {
				for (let r = playerX - blockRenderDist; r <= playerX + blockRenderDist; r++) {
					drawCoord(r, c);
				}
			}
			for (let c = playerZ - blockRenderDist + 1; c >= playerZ - blockRenderDist; c--) {
				for (let r = playerX - blockRenderDist; r <= playerX + blockRenderDist; r++) {
					drawCoord(r, c);
				}
			}
			for (let r = playerX + blockRenderDist - 1; r <= playerX + blockRenderDist; r++) {
				for (let c = playerZ - blockRenderDist; c <= playerZ + blockRenderDist; c++) {
					drawCoord(r, c);
				}
			}
			for (let r = playerX - blockRenderDist + 1; r >= playerX - blockRenderDist; r--) {
				for (let c = playerZ - blockRenderDist; c <= playerZ + blockRenderDist; c++) {
					drawCoord(r, c);
				}
			}
		}

		function removeBlocks(playerX, playerZ) {
			for (var i in scene.children) {
				let block = scene.children[i];
				if (block.name == "block" || block.name == "bottom") {
					if (Math.abs(playerZ - block.position.z) > blockRenderDist-0.9 || Math.abs(playerX - block.position.x) > blockRenderDist-0.9) {
						scene.remove(block);
					}
				}
			}
		}

		let velocity = new THREE.Vector3(0, 0, 0);
		let time = 0;
		let canJump = false;
		function playerPhysics(speed, delta) {
			let x = Math.floor(camera.position.x + 0.5);
			let y = Math.floor(camera.position.y + 0.5);
			let z = Math.floor(camera.position.z + 0.5);
			let key = getKey(x, z);
			let actualSpeed = speed * delta;
			if (data[key][y-2] == null) {
				camera.position.y += actualSpeed * velocity.y;
				velocity.y -= 10*delta;
			} else {
				if (velocity.y < 0) {
					velocity.y = 0;
				}
				camera.position.y += actualSpeed * velocity.y;
			}
		}

		let INTERSECTED;
		let face;
		let col;
		function checkMouse() {
			let raycaster = new THREE.Raycaster();
			const center = new THREE.Vector2(0, 0);
			raycaster.setFromCamera( center, camera );
			const intersects = raycaster.intersectObjects( scene.children );
			if (intersects.length > 0) {
				if (face != intersects[0].face) {
					if (face) {
						let faces = INTERSECTED.geometry.faces;
						for (let i = 0; i < faces.length; i++) {
							faces[i].color.setRGB(col.r, col.g, col.b);
						}
						INTERSECTED.geometry.colorsNeedUpdate = true;
					}
					face = intersects[0].face;
					INTERSECTED = intersects[0].object;
					let faces = INTERSECTED.geometry.faces;
					for (let i = 0; i < faces.length; i++) {
						if (faces[i].normal.x == face.normal.x && faces[i].normal.y == face.normal.y && faces[i].normal.z == face.normal.z) {
							//faces[i].color.setRGB(255, 255, 255);
							faces[i].color.setRGB(faces[i].color.r + 1, faces[i].color.g + 1, faces[i].color.b + 1);
						} else {
							col = faces[i].color;
						}
					}
					INTERSECTED.geometry.colorsNeedUpdate = true;
				}
			} else {
				if (face) {
					let faces = INTERSECTED.geometry.faces;
					for (let i = 0; i < faces.length; i++) {
						faces[i].color.setRGB(col.r, col.g, col.b);
					}
					INTERSECTED.geometry.colorsNeedUpdate = true;
				}
				face = null;
				INTERSECTED = null;
			}
		}

		function drawScene() {
			renderer.render(scene, camera);
			let delta = clock.getDelta();
			if (pause) {
				processKeyboard(delta);
				processLand();
				checkMouse();
			}
			requestAnimationFrame(drawScene);
		}

		drawScene();

	</script>
</body>

</html>
